


@Order или @Priority - указывает бину какой порядок ему принемать к коллекции/массиве


------------------------------------------------------------------------------------------------------------------------


Аннотации стереотипы
    Это аннотации, которые присваеваються классам, что выполняют определенные часто используемые роли

@Component или @Named
    Это обобщенная аннотация, для любого Spring-упровляемого обьекта класса.
    @Repository, @Controller, @Service - все частные случаи этой аннотации.

@Repository
    Аннтоция являеться маркером для классов что представляют собой стереотип доступа к базе ( известным, как DAO )

@Controller
    Анноатция используеться для выделение классов контроллеров в Spring MVC

@Service
    Аннотация для указания класса, как сервиса, часто


------------------------------------------------------------------------------------------------------------------------

Настройка контектста из Java

@ComponentScan
    Анноатиця указывает пакеты в параметре basePackages, которые необходимо просканировать для посика
    конфигирируемых компонентов для Spring используеться вместе с Configuration, так же можно использовать value параметр:

        @Configuration
        @ComponentScan(basePackages = "org.example") // или @ComponentScan("org.example")
        public class AppConfig  {
        ...

    Так же есть возможность настроить фильтрацию для классов, более детально смотри
    context/Расширинные настройки контекста.txt "context:component-scan":

    @ComponentScan(basePackages = "org.example",
            includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
            excludeFilters = @Filter(Repository.class))

------------------------------------------------------------------------------------------------------------------------

@Scope

------------------------------------------------------------------------------------------------------------------------

@Lazy

Квалифицирует бин как бин с отложенной загрузкой, так же можно указать для полей помеченных как @Autowired или @Inject,
тогда спринг загрузит поле в момент обращение к ниму


------------------------------------------------------------------------------------------------------------------------

@Singleton - JSR-330

Тоже что и Scope("singleton")

------------------------------------------------------------------------------------------------------------------------

@Bean
    Анноатация используеться, когда нужно указать что данный метод, формирует новый обьект, которй в последствии будет
    использоваться контейнером Spring.

    Когда методы, аннотированные Bean находяться в классе не Configuration, такие методы называються легковесными.
    Такие методы, не могут обращяться к другим методам Bean для получение зависимостей

    Рекомедуемо создовать бины только в класса аннотированным Configuration, во избежание проблем с ограничениями
    lite-mode


------------------------------------------------------------------------------------------------------------------------

@Configuration
    Анноатация используеться, когда нужно указать что данный класс, используеться для настройки контекста Spring,
    вызывает у себя аннотированые методы @Bean

    @Configuration
    public class AppConfig {                Эквивалент к XML:     <beans>
                                                                     <bean id="myService" class="com.acme.services.MyServiceImpl"/>
        @Bean                                                     </beans>
        public MyService myService() {
            return new MyServiceImpl();
        }

    }

    Нужн понять что формирования контекста, только с помошью java, ограничивает реализацию спринга, и не повзоляет
    выполнять некоторые более гибкие действия, которые с легкостью выполнялись бы в xml.
    Хорошей практикой будет совмещение этих подходов, как пример:

    Класс:                                                          XML:

    @Configuration                                                  <beans>
    public class AppConfig {                                          <!-- Активировать обрабутку аннотаций таких как @Autowired и @Configuration -->
        @Autowired                                                    <context:annotation-config/>
        private DataSource dataSource;
        @Bean                                                         <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
        public AccountRepository accountRepository() {
            return new JdbcAccountRepository(dataSource);             <bean class="com.acme.AppConfig"/>
        }
        @Bean                                                         <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        public TransferService transferService() {                       <property name="url" value="${jdbc.url}"/>
            return new TransferService(accountRepository());             <property name="username" value="${jdbc.username}"/>
        }                                                                <property name="password" value="${jdbc.password}"/>
    }                                                                  </bean>
                                                                    </beans>

    Файл настройки:

        jdbc.properties
        jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
        jdbc.username=sa
        jdbc.password=


------------------------------------------------------------------------------------------------------------------------
@ImportResource

Аннотация @Import анологична тегу <import /> в xml, она импортирует xml конфигурацию

------------------------------------------------------------------------------------------------------------------------

@Import

Аннотация @Import анологична тегу <import /> в xml, она импортирует класс конфигурацию

------------------------------------------------------------------------------------------------------------------------

 @Profile

 Частный случай @Conditional, принемает текстовый парметр, и ищеет на соответсвие в доступных параметрах среды.

 Эта функциональность, полезна при запуске нескольких разных бинов, одного типа, к примеру для продуктива или девелопа:

        @Configuration
        @Profile("dev")
        public class StandaloneDataConfig {
            @Bean
            public DataSource dataSource() {
                return new EmbeddedDatabaseBuilder()
                    .setType(EmbeddedDatabaseType.HSQL)
                    .addScript("classpath:com/bank/config/sql/schema.sql")
                    .addScript("classpath:com/bank/config/sql/test-data.sql")
                    .build();
            }
        }

        @Configuration
        @Profile("production")
        public class JndiDataConfig {
            @Bean
            public DataSource dataSource() throws Exception {
                Context ctx = new InitialContext();
                return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
            }
        }

   Профайлер может быть и мето-аннотацией:

   @Target(ElementType.TYPE)
   @Retention(RetentionPolicy.RUNTIME)
   @Profile("production")
   public @interface Production {
   }

   теперь @Production = @Profile("production")

   Если @Profile("production") помечен @Profile, все методы @Bean и @Import будут проверяться на условие, если в
   других конфигурациях нет своего @Profile

   Так же можно указывать множественные свойства: @Profile({"p1", "p2"}), озночает что бин будет активирован только
   если p1 и/или p2 активны
   Отрицание: @Profile({"p1", "!p2"}) = региттсрация бина будет выполненна если p1 активна или p2 не активна


------------------------------------------------------------------------------------------------------------------------

 @Conditional

 Аннотация, которая помечает @Bean метод, и указывает на небходиомсть удовлетворение условие прежде чем можно будет
 создать бин


------------------------------------------------------------------------------------------------------------------------

@PropertySource

    Аннотация предостовляет деклератиный механизм для добовление файла настроек к Spring’s Environment:


        @Configuration
        @PropertySource("classpath:/com/myco/app.properties")

        Такж как можно изспользовать EL ${..}, для получние параметров из существующих настроек:
        @PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties"), где


        public class AppConfig {

            @Autowired
            Environment env;
            @Bean
            public TestBean testBean() {
                TestBean testBean = new TestBean();
                testBean.setName(env.getProperty("testbean.name"));
                return testBean;
            }
        }

------------------------------------------------------------------------------------------------------------------------

@EnableLoadTimeWeaving

LoadTimeWeaver используеться спрингом для диномической трансформации классов, в момент загрузки их в JVM

Эта аннотация должна быть добавленна, в конфигурационный класс, если нужно активировать LoadTimeWeaver


------------------------------------------------------------------------------------------------------------------------

@EnableAspectJAutoProxy

    Аннотация инициализирует поддержку @AspectJ, @Aspect

------------------------------------------------------------------------------------------------------------------------

@AspectJ

    Аннотация позволяет форимровать аспекты, как часть АОП в Spring
    Spring исползует аннотацию AspectJ 5, но раобтает на основе SpringAOP а не AspectJ

------------------------------------------------------------------------------------------------------------------------

@Aspect
    Аннотация для регистрации класса, как аспект. Не фиксируеться classpath поиском, для того что бы класс был найден
    нужно добавить еще аннотацию @Component либо эквивалентные, аннотированые классы не проксируються Spring

------------------------------------------------------------------------------------------------------------------------

@Pointcut
    Региатрция точки точка соединения связызвет условия выполнения с аспектом
    Состоит из двух параметров:
        1.Имена аспектов
        2.Выражение что указывает на применение аспектов к удовлетворяющим методам



------------------------------------------------------------------------------------------------------------------------

@EnableLoadTimeWeaving

    Включает использования в Spring Aspect внедрение

------------------------------------------------------------------------------------------------------------------------

@EnableAsync

    добовляеться к конфигурационному классу, что позволяет запускать методы асинхронно, используя аннотацию  @Async

------------------------------------------------------------------------------------------------------------------------

@EnableScheduling

    добовляеться к конфигурационному классу, что позволяет запускать методы в определенных временных условиях,
    используя аннотацию @Scheduled


------------------------------------------------------------------------------------------------------------------------

@Scheduled
    Используеться для вызова методов, в определенные периуды времени

    Требования: метод должен быть без аргументов, метод возвращает void,
                не рекомендованно что бы метод был в конфигурационном классе

    fixedDelay : период с момента завершения каждого предыдущего вызова.
    fixedRate : период с момента успещного вызова метода
    initialDelay : укзаывает на время ожидание перед первым вызовом метода
    cron : Принемает крон выражение для форимрование графика выполнения метода
    zone : Используеться в сочетании с cron, для уточнения временной зоны, выражения


------------------------------------------------------------------------------------------------------------------------

@Async
    Используеться для того что бы вызов метода был асинхронным. Другими словами, упраление вернеться сразу к вызвающему
    потоку после вызова метода:

    Простой способ:
        @Async
        void doSomething() {
            // this will be executed asynchronously
        }


    Либо использовать аргументы:

        @Async
        void doSomething(String s) {
            // this will be executed asynchronously
        }

    Если метод, должен возвращать значение, то значение должно быть в Future:

        @Async
        Future<String> returnSomething(int i) {
            // this will be executed asynchronously
        }

    По умолчанию, ассинхронные методы, выполняються TaskExecutor что указан в annotation-driven директиве, но можно указать
    на прямую какой TaskExecutor, должен выполнить метод

    @Async("otherExecutor")
    void doSomething(String s) {
        // this will be executed asynchronously by "otherExecutor"
    }

------------------------------------------------------------------------------------------------------------------------

@EnableCaching

    Конфигурационная аннотация, добовляеться в класс @Configurable, для активации кеша в системе

    Параметры:
        mode - ( по умолчанию proxy ) proxy - обычный Spring AOP, aspectj - использует AspectJ weaver
        proxyTargetClass -  ( по умолчанию false ) Если true, то исопльзуеться прокси на основе классов, если false
                            то используеться стандартое JDK интерфейсное проксирование
        order - ( по умолчанию  Ordered.LOWEST ) Выполнение проксиирование в порядке остальных проксирующих методов

------------------------------------------------------------------------------------------------------------------------

@Cacheable
    Кеширует результат метода

    Параметры:
        value - имя группы кешированных обьектов
        key - укзать алгоритм форирование ключа
        keyGenerator - указать на собственный генератор ключей ( использование с key вызывает исключение )
        cacheManager - указать на другой менеджер кеша
        cacheResolver - укзать не собственный контекст кеша
        condition - указать улсловие кеширование результатов

                    @Cacheable(value="book", condition="#name.length < 32")
                    public Book findBook(String name)
        unless - используеться вместе с condition, для отмены условия

                    @Cacheable(value="book", condition="#name.length < 32", unless="#result.hardback")
                    public Book findBook( String name )


    Пример:
        @Cacheable("books")
        public Book findBook(ISBN isbn) {...}


------------------------------------------------------------------------------------------------------------------------

@CacheEvict
    Очищает кеш, во время вызова метода

    Параметры:
        allEntries - [true|false] - указывает очищать всесь кеш или по ключу
        beforeInvocation - [true|false] указывает режим вызова перед, в случае true, и после в случае false

------------------------------------------------------------------------------------------------------------------------

@CachePut
    Обновляет кеш, без вмешательства в работу метода, т.е не возвращает закешированный результа не выходе.
    Поддреживает все параметры, что и аннотация @Cacheable. Используеться для уведомление кеша, чем для оптимизации

    Пример:
        @CachePut(value="book", key="#isbn")
        public Book updateBook(ISBN isbn, BookDescriptor descriptor)
    Важно:
        Использовать аннотации @CachePut и @Cacheable не рекомендуеться потому что они имеют разные поведения и
        могут привисти к неожиданным результатам

------------------------------------------------------------------------------------------------------------------------

@Caching
    Перегрупировывает несколько операций с кешом, которые связанны с вызовом метода

    Пример:

        @Caching(evict = { @CacheEvict("primary"), @CacheEvict(value="secondary", key="#p0") })
        public Book importBooks(String deposit, Date date)


------------------------------------------------------------------------------------------------------------------------

@CacheConfig
    Распостраняет некоторые основные настройки связанные с кешом на уровне класса

    Параметры:
        value - имя группы кешированных обьектов
        keyGenerator - указать на собственный генератор ключей ( использование с key вызывает исключение )
        cacheManager - указать на другой менеджер кеша
        cacheResolver - укзать не собственный контекст кеша

    Пример:
        @CacheConfig("books")
        public class BookRepositoryImpl implements BookRepository {
            @Cacheable
            public Book findBook(ISBN isbn) {...}
        }




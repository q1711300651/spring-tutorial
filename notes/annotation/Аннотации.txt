@ConstructorProperties - аннотация представлет собой стек названий аргументов в контруторе/фабричном метода для
                         внедрение зависимости через имя аргумента

------------------------------------------------------------------------------------------------------------------------

@Required - аннотация указывает на свойство, которое обязательно должно быть заполененно.

------------------------------------------------------------------------------------------------------------------------

@Autowired или @Inject - отмечаеткак требующий автозаполнения внедрение зависимости Spring.

Используя эту аннотацию, не нужно заботиться о том, как лучше всего передать классу или bean'у экземпляр другого bean'a.
Фреймворк Spring сам найдет нужный bean и подставит его значение в свойство, которое отмечено аннотацией @Autowired.

Пример для сеттера:

     @Autowired
        public void setMovieFinder(MovieFinder movieFinder) {
            this.movieFinder = movieFinder;
        }

Пример для метода, Конструтора:

    @Autowired
    public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

Пример для поля:

    @Autowired
    private MovieFinder movieFinder;

Таже возможно внедрить все бины, одного типа в поле массив

     @Autowired
     private MovieCatalog[] movieCatalogs;

или для коллекций

     private Set<MovieCatalog> movieCatalogs;
        @Autowired
        public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
            this.movieCatalogs = movieCatalogs;
        }

Или даже Карты, где ключом обязательно должнен быть тип Строки, где будет имя бина, а значение типа:


     @Autowired
        public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
            this.movieCatalogs = movieCatalogs;
        }



Также можно использовать Autowired для внедрение стандартного интерфейся спринга ( BeanFactory,  ApplicationContext,
    Environment,  ResourceLoader, ApplicationEventPublisher,  and  MessageSource)

     @Autowired
     private ApplicationContext context;


Параметры

    required - по умаолчанию Autowired падает, когда не находит нужный тип для внедрение, это поведение можно изменить
               указав false в данный параметр
                    @Autowired(required=false)


Важно
@Autowired,  @Inject,  @Resource,  and  @Value - используют страндартную BeanPostProcessor реализвацю, что значит что они
неподдерживают собственные  BeanPostProcessor or BeanFactoryPostProcessor типы, используйте xml или java конфигурацию

------------------------------------------------------------------------------------------------------------------------

@Qualifier или @Named

    Из-за того что Autowired может найти несколько кандидатов на указанный тип в бине, для уточнения испольуется Qualifier:

        @Autowired
        @Qualifier("main")
        private MovieCatalog movieCatalog;

        или для аргумента

        @Autowired
        public void prepare(@Qualifier("main")MovieCatalog movieCatalog...

        Qualifier - это не сслыка на id бина, а лишь совпадение с ним, правельным решением использования будет
        применять имена для id и Qualifier, какхарастиристика, к примеру main или persistent:

             <bean class="example.SimpleMovieCatalog">
                    <qualifier value="main"/>
             </bean>

        Так же с помошью Qualifier, можно соберать подгрупу бинов в коллекции, которые совпадают с указанным qualifier


    Можно создасть собственный квалификатор

    @Qualifier
    public @interface Genre {
        String value(); // Можно и без параметров, квалифицируя только по типу

        Format format(); // Или же добовлять собственные,

    }
    ....
    @Autowired @Genre("Action")
    private MovieCatalog actionCatalog;
    ...
    <bean class="example.MovieCatalog">
         <qualifier type="Genre" value="Action">
             <attribute key="format" value="VHS"/> <!-- Тогда нужно добавит под-тэг в квалификатор -->
         </qualifier>
    </bean>



    Использования дженериков, в качетсве квалификаторов:

    Скажем интерфейс Store<T> имеет два дочерних интерфейсов StringStore extend Store<String> и
        IntegerStore extend Store<Integer>, тогда в с java контекстов, будет выглядить так:

            @Configuration
            public class MyConfiguration {
                @Bean public StringStore stringStore() { return new StringStore(); }
                @Bean public IntegerStore integerStore() { eturn new IntegerStore(); }
            }
            ...
            @Autowired
            private Store<String> s1; // <String> квалификатор, внедряет stringStore бин
            @Autowired
            private Store<Integer> s2; // <Integer>  квалификатор, внедряет integerStore бин
            @Autowired
            private List<Store<Integer>> s; // работает и с коллекцией, картой, последовательностью


    Для регистрации квалификаторов без аннотации используеться CustomAutowireConfigurer:

        <bean id="customAutowireConfigurer"
                class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
            <property name="customQualifierTypes">
                <set>
                    <value>example.CustomQualifier</value>
                </set>
            </property>
        </bean>


    Использования Qualifier так же можно для классификации компонента:

    @Component
    @Qualifier("Action")
    public class ActionMovieCatalog implements MovieCatalog { ... }



------------------------------------------------------------------------------------------------------------------------

@PostConstruct, @PreDestroy - Аннотации для вызова методов на события жизненого цикла обьект
                                        (после создания, перед удалением, соотвественно )


------------------------------------------------------------------------------------------------------------------------

@Order или @Priority - указывает бину какой порядок ему принемать к коллекции/массиве


------------------------------------------------------------------------------------------------------------------------

@Resource

    Спринг поддерживает внедрение используя JSR-250 аннотацию Resource для полей и сеттеров.
    Resource принемает параметр "name", и по умолчанию Spring выполняет поиск по именам бинов, если имя не указанно, то
    береться имя поля

    Так же в особых случаях Resource может использоваться, как Autowired то есть искать бин для внедрене по его типу,
    к примеру:

        @Resource
        private ApplicationContext context; // имени контест нет в дескрипторе, а значить внедрение выполнилось по типу
        бина

------------------------------------------------------------------------------------------------------------------------

Аннотации стереотипы
    Это аннотации, которые присваеваються классам, что выполняют определенные часто используемые роли

@Component или @Named
    Это обобщенная аннотация, для любого Spring-упровляемого обьекта класса.
    @Repository, @Controller, @Service - все частные случаи этой аннотации.

@Repository
    Аннтоция являеться маркером для классов что представляют собой стереотип доступа к базе ( известным, как DAO )

@Controller
    Анноатция используеться для выделение классов контроллеров в Spring MVC

@Service
    Аннотация для указания класса, как сервиса, часто


------------------------------------------------------------------------------------------------------------------------

Настройка контектста из Java

@Configuration
    Аннотация указывает, что данный класс, конфигурирует Spring контекст доповляя собственные бины и доп. параметры

@ComponentScan
    Анноатиця указывает пакеты в параметре basePackages, которые необходимо просканировать для посика
    конфигирируемых компонентов для Spring используеться вместе с Configuration, так же можно использовать value параметр:

        @Configuration
        @ComponentScan(basePackages = "org.example") // или @ComponentScan("org.example")
        public class AppConfig  {
        ...

    Так же есть возможность настроить фильтрацию для классов, более детально смотри
    context/Расширинные настройки контекста.txt "context:component-scan":

    @ComponentScan(basePackages = "org.example",
            includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
            excludeFilters = @Filter(Repository.class))

------------------------------------------------------------------------------------------------------------------------

@Scope

------------------------------------------------------------------------------------------------------------------------

@Lazy

Квалифицирует бин как бин с отложенной загрузкой, так же можно указать для полей помеченных как @Autowired или @Inject,
тогда спринг загрузит поле в момент обращение к ниму


------------------------------------------------------------------------------------------------------------------------

@Singleton - JSR-330

Тоже что и Scope("singleton")

------------------------------------------------------------------------------------------------------------------------

@Bean
    Анноатация используеться, когда нужно указать что данный метод, формирует новый обьект, которй в последствии будет
    использоваться контейнером Spring.

    Когда методы, аннотированные Bean находяться в классе не Configuration, такие методы называються легковесными.
    Такие методы, не могут обращяться к другим методам Bean для получение зависимостей

    Рекомедуемо создовать бины только в класса аннотированным Configuration, во избежание проблем с ограничениями
    lite-mode


------------------------------------------------------------------------------------------------------------------------

@Configuration
    Анноатация используеться, когда нужно указать что данный класс, используеться для настройки контекста Spring,
    вызывает у себя аннотированые методы @Bean

    @Configuration
    public class AppConfig {                Эквивалент к XML:     <beans>
                                                                     <bean id="myService" class="com.acme.services.MyServiceImpl"/>
        @Bean                                                     </beans>
        public MyService myService() {
            return new MyServiceImpl();
        }

    }

    Нужн понять что формирования контекста, только с помошью java, ограничивает реализацию спринга, и не повзоляет
    выполнять некоторые более гибкие действия, которые с легкостью выполнялись бы в xml.
    Хорошей практикой будет совмещение этих подходов, как пример:

    Класс:                                                          XML:

    @Configuration                                                  <beans>
    public class AppConfig {                                          <!-- Активировать обрабутку аннотаций таких как @Autowired и @Configuration -->
        @Autowired                                                    <context:annotation-config/>
        private DataSource dataSource;
        @Bean                                                         <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
        public AccountRepository accountRepository() {
            return new JdbcAccountRepository(dataSource);             <bean class="com.acme.AppConfig"/>
        }
        @Bean                                                         <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        public TransferService transferService() {                       <property name="url" value="${jdbc.url}"/>
            return new TransferService(accountRepository());             <property name="username" value="${jdbc.username}"/>
        }                                                                <property name="password" value="${jdbc.password}"/>
    }                                                                  </bean>
                                                                    </beans>

    Файл настройки:

        jdbc.properties
        jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
        jdbc.username=sa
        jdbc.password=


------------------------------------------------------------------------------------------------------------------------
@ImportResource

Аннотация @Import анологична тегу <import /> в xml, она импортирует xml конфигурацию

------------------------------------------------------------------------------------------------------------------------

@Import

Аннотация @Import анологична тегу <import /> в xml, она импортирует класс конфигурацию

------------------------------------------------------------------------------------------------------------------------

 @Profile

 Частный случай @Conditional, принемает текстовый парметр, и ищеет на соответсвие в доступных параметрах среды.

 Эта функциональность, полезна при запуске нескольких разных бинов, одного типа, к примеру для продуктива или девелопа:

        @Configuration
        @Profile("dev")
        public class StandaloneDataConfig {
            @Bean
            public DataSource dataSource() {
                return new EmbeddedDatabaseBuilder()
                    .setType(EmbeddedDatabaseType.HSQL)
                    .addScript("classpath:com/bank/config/sql/schema.sql")
                    .addScript("classpath:com/bank/config/sql/test-data.sql")
                    .build();
            }
        }

        @Configuration
        @Profile("production")
        public class JndiDataConfig {
            @Bean
            public DataSource dataSource() throws Exception {
                Context ctx = new InitialContext();
                return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
            }
        }

   Профайлер может быть и мето-аннотацией:

   @Target(ElementType.TYPE)
   @Retention(RetentionPolicy.RUNTIME)
   @Profile("production")
   public @interface Production {
   }

   теперь @Production = @Profile("production")

   Если @Profile("production") помечен @Profile, все методы @Bean и @Import будут проверяться на условие, если в
   других конфигурациях нет своего @Profile

   Так же можно указывать множественные свойства: @Profile({"p1", "p2"}), озночает что бин будет активирован только
   если p1 и/или p2 активны
   Отрицание: @Profile({"p1", "!p2"}) = региттсрация бина будет выполненна если p1 активна или p2 не активна


------------------------------------------------------------------------------------------------------------------------

 @Conditional

 Аннотация, которая помечает @Bean метод, и указывает на небходиомсть удовлетворение условие прежде чем можно будет
 создать бин


------------------------------------------------------------------------------------------------------------------------

@PropertySource

    Аннотация предостовляет деклератиный механизм для добовление файла настроек к Spring’s Environment:


        @Configuration
        @PropertySource("classpath:/com/myco/app.properties")

        Такж как можно изспользовать EL ${..}, для получние параметров из существующих настроек:
        @PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties"), где


        public class AppConfig {

            @Autowired
            Environment env;
            @Bean
            public TestBean testBean() {
                TestBean testBean = new TestBean();
                testBean.setName(env.getProperty("testbean.name"));
                return testBean;
            }
        }

------------------------------------------------------------------------------------------------------------------------

@EnableLoadTimeWeaving

LoadTimeWeaver используеться спрингом для диномической трансформации классов, в момент загрузки их в JVM

Эта аннотация должна быть добавленна, в конфигурационный класс, если нужно активировать LoadTimeWeaver


------------------------------------------------------------------------------------------------------------------------

@EnableAspectJAutoProxy

    Аннотация инициализирует поддержку @AspectJ, @Aspect

------------------------------------------------------------------------------------------------------------------------

@AspectJ

    Аннотация позволяет форимровать аспекты, как часть АОП в Spring
    Spring исползует аннотацию AspectJ 5, но раобтает на основе SpringAOP а не AspectJ

------------------------------------------------------------------------------------------------------------------------

@Aspect
    Аннотация для регистрации класса, как аспект. Не фиксируеться classpath поиском, для того что бы класс был найден
    нужно добавить еще аннотацию @Component либо эквивалентные, аннотированые классы не проксируються Spring

------------------------------------------------------------------------------------------------------------------------

@Pointcut
    Региатрция точки точка соединения связызвет условия выполнения с аспектом
    Состоит из двух параметров:
        1.Имена аспектов
        2.Выражение что указывает на применение аспектов к удовлетворяющим методам



------------------------------------------------------------------------------------------------------------------------

@EnableLoadTimeWeaving

    Включает использования в Spring Aspect внедрение

------------------------------------------------------------------------------------------------------------------------

@EnableAsync

    добовляеться к конфигурационному классу, что позволяет запускать методы асинхронно, используя аннотацию  @Async

------------------------------------------------------------------------------------------------------------------------

@EnableScheduling

    добовляеться к конфигурационному классу, что позволяет запускать методы в определенных временных условиях,
    используя аннотацию @Scheduled


------------------------------------------------------------------------------------------------------------------------

@Scheduled
    Используеться для вызова методов, в определенные периуды времени

    Требования: метод должен быть без аргументов, метод возвращает void,
                не рекомендованно что бы метод был в конфигурационном классе

    fixedDelay : период с момента завершения каждого предыдущего вызова.
    fixedRate : период с момента успещного вызова метода
    initialDelay : укзаывает на время ожидание перед первым вызовом метода
    cron : Принемает крон выражение для форимрование графика выполнения метода
    zone : Используеться в сочетании с cron, для уточнения временной зоны, выражения


------------------------------------------------------------------------------------------------------------------------

@Async
    Используеться для того что бы вызов метода был асинхронным. Другими словами, упраление вернеться сразу к вызвающему
    потоку после вызова метода:

    Простой способ:
        @Async
        void doSomething() {
            // this will be executed asynchronously
        }


    Либо использовать аргументы:

        @Async
        void doSomething(String s) {
            // this will be executed asynchronously
        }

    Если метод, должен возвращать значение, то значение должно быть в Future:

        @Async
        Future<String> returnSomething(int i) {
            // this will be executed asynchronously
        }

    По умолчанию, ассинхронные методы, выполняються TaskExecutor что указан в annotation-driven директиве, но можно указать
    на прямую какой TaskExecutor, должен выполнить метод

    @Async("otherExecutor")
    void doSomething(String s) {
        // this will be executed asynchronously by "otherExecutor"
    }

------------------------------------------------------------------------------------------------------------------------

@EnableCaching

    Конфигурационная аннотация, добовляеться в класс @Configurable, для активации кеша в системе

    Параметры:
        mode - ( по умолчанию proxy ) proxy - обычный Spring AOP, aspectj - использует AspectJ weaver
        proxyTargetClass -  ( по умолчанию false ) Если true, то исопльзуеться прокси на основе классов, если false
                            то используеться стандартое JDK интерфейсное проксирование
        order - ( по умолчанию  Ordered.LOWEST ) Выполнение проксиирование в порядке остальных проксирующих методов

------------------------------------------------------------------------------------------------------------------------

@Cacheable
    Кеширует результат метода

    Параметры:
        value - имя группы кешированных обьектов
        key - укзать алгоритм форирование ключа
        keyGenerator - указать на собственный генератор ключей ( использование с key вызывает исключение )
        cacheManager - указать на другой менеджер кеша
        cacheResolver - укзать не собственный контекст кеша
        condition - указать улсловие кеширование результатов

                    @Cacheable(value="book", condition="#name.length < 32")
                    public Book findBook(String name)
        unless - используеться вместе с condition, для отмены условия

                    @Cacheable(value="book", condition="#name.length < 32", unless="#result.hardback")
                    public Book findBook( String name )


    Пример:
        @Cacheable("books")
        public Book findBook(ISBN isbn) {...}


------------------------------------------------------------------------------------------------------------------------

@CacheEvict
    Очищает кеш, во время вызова метода

    Параметры:
        allEntries - [true|false] - указывает очищать всесь кеш или по ключу
        beforeInvocation - [true|false] указывает режим вызова перед, в случае true, и после в случае false

------------------------------------------------------------------------------------------------------------------------

@CachePut
    Обновляет кеш, без вмешательства в работу метода, т.е не возвращает закешированный результа не выходе.
    Поддреживает все параметры, что и аннотация @Cacheable. Используеться для уведомление кеша, чем для оптимизации

    Пример:
        @CachePut(value="book", key="#isbn")
        public Book updateBook(ISBN isbn, BookDescriptor descriptor)
    Важно:
        Использовать аннотации @CachePut и @Cacheable не рекомендуеться потому что они имеют разные поведения и
        могут привисти к неожиданным результатам

------------------------------------------------------------------------------------------------------------------------

@Caching
    Перегрупировывает несколько операций с кешом, которые связанны с вызовом метода

    Пример:

        @Caching(evict = { @CacheEvict("primary"), @CacheEvict(value="secondary", key="#p0") })
        public Book importBooks(String deposit, Date date)


------------------------------------------------------------------------------------------------------------------------

@CacheConfig
    Распостраняет некоторые основные настройки связанные с кешом на уровне класса

    Параметры:
        value - имя группы кешированных обьектов
        keyGenerator - указать на собственный генератор ключей ( использование с key вызывает исключение )
        cacheManager - указать на другой менеджер кеша
        cacheResolver - укзать не собственный контекст кеша

    Пример:
        @CacheConfig("books")
        public class BookRepositoryImpl implements BookRepository {
            @Cacheable
            public Book findBook(ISBN isbn) {...}
        }



